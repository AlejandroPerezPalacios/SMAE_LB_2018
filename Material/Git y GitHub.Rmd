---
title: "Git y GitHub"
author: "León Berdichevsky Acosta"
date: "Agosto 16, 2018"
output: "html_document"
---


****

## Controlador de versiones 

### Contenido
+ ¿Qué es un controlador de versiones?
+ Tipos de controladores de versiones
+ Git
    + Conceptos
    + Commandos
+ GitHub y Bitbucket
+ Una buena estrategia para administración de versiones
+ Git flow
+ Tutoriales
+ Referencias

*** 

### ¿Qué es un controlador de versiones?

Un sistema de control de versiones (VCS) permite administrar los cambios en archivos de manera **adecuada**, entendiedo como archivos: imágenes, documentos, código, etc. 
 
*¿Y eso qué significa?* 

Que puedes tener el histórico de los cambios que se han realizado en un archivo desde que lo subiste al sistema de versión de controles. 

*¿Para qué es útil un VCS?* 

+ Permitir que más de una persona trabaje en el mismo archivo al mismo tiempo.
+ Integrar los cambios realizados por todos los involucrados en el proyecto.
+ Identificar quién realizó qué cambio y cuándo.
+ Identificar los posibles conflictos entre versiones que se puedan tener.
+ Obtener versiones anteriores del archivo. 

Es natural que en un equipo de desarrollo de software se utilice un sistema de control de versiones, pero hoy en día no es único a estos equipos; siendo un científico de datos **debes** mantener la administración del código/documentación/artículos que generas SIEMPRE! y 95% seguro que al formar parte de un equipo NECESITARÁS por el bien de todos administrar todo lo que generas.
 
***

### Tipos de controladores de versiones 

#### Controlador de versiones local

Es la forma más sencilla de llevar una administración de control de versiones. Un caso de este tipo controlador de versiones es cuando guardas en tu máquina archivos con diferentes nombres conforme vas avanzando en él. Seguramente más de una vez hiciste esta aberración. Por ejemplo:

+ proyecto_final.doc
+ proyecto_final_1.doc
+ proyecto_final_final.doc
+ proyecto_final_final_final.doc
+ ...


¡Varias cosas que estan mal! 

1. Para empezar, en este ejemplo se trata de un archivo en formato .doc. La situación cambia cuando se utiliza markdown/Rmd/org para generar documentos mucho más profesionales y con una presentación limpia y visualmente estética. 

2. Esto solo funciona parcialmente si únicamente eres tú el que está modificando el archivo. Cuando se trata de trabajo en equipo esto no es práctico y raravez funciona.

2. ¿Qué pasa si se te olvida guardar el archivo con alguna actualización? Pierdes pequeños/grandes cambios realizados.

3. ¿Qué pasa si le pones el mismo nombre a una nueva versión del archivo? Pierdes todo el historial: si te equivocaste, al final no hay como regresar a la versión anterior.

4. ¿Qué pasa si un día tu equipo de cómputo se desconfigura o simplemente ya no prende? Pierdes todo el trabajo.


Uno de las herramientas útiles para este sistema de control de versiones es un *Revision Control System* (RCS) (MAC tiene instalado rcs). RCS guarda en una base de datos local pequeños parches del archivo original donde almacena solo las diferencias; esto es, puede volver a recrear un archivo al juntar todos los parches guardados.

$\rightarrow$ ¡No utilices este sistema de control de versiones!

![](../images/local_version_control.png)

\*Imágenes tomadas de [Getting Started About Version Control](https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control)



#### Controlador de versiones centralizado

Esta solución era la más popular y estándar hace algun tiempo: Las herramientas de software CVS y Subversion pertenecen a este tipo de controlador de versiones. 

En esta solución existe un sólo servidor que tiene las versiones de los archivos y el historial de los clientes que se contectan a este servidor para bajar, subir o actualizar cambios a los archivos administrados en él. Claramente esta configuración server-client resuelve varios de los problemas identificados en la versión local de control de versiones: 

+ Permite a varias personas trabajar en un mismo archivo al mismo tiempo.
+ Es fácil saber quién está trabajando en qué archivo, quién hizo el último cambio.
+ Es más sencillo administrar y dar mantenimiento a un solo servidor que a todas las bases de datos de clientes locales.

El problema de esta solución es que hay un punto de falla: el servidor central. Sin servidor no hay administración de versiones, ni versiones por lo que si le llega a pasar algo al servidor central... Por ejemplo: si por alguna razón el servidor se cae una hora, el equipo no puede subir actualizaciones, o bajar archivos para trabajar. No está por demás mencionar que es buena práctica generar un respaldo de lo que contiene el servidor para evitar perder toda la historia y poder recuperar información en caso de algún problema.

![](../images/centralized_version_control.png)

\*Imágenes tomadas de [Getting Started About Version Control](https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control)


#### Controlador de versiones distribuido

En este tipo de administración de control de versiones no hay como tal un servidor central, todos los *clientes* tienen una copia del repositorio **completa** localmente; esto resuelve el problema de que si el "servidor central" se cae -aunque aquí no hay servidor central-, cada cliente puede seguir trabajando. Por otro lado, si el servidor de alguno de los clientes se muere y estaba colaborando en alguno de los repositorios es posible que algún otro cliente pueda regresar lo perdido al servidor, ya que todos tienen una copia local completa. 

Esta es la manera en la que Git, Mercurial, Bazaar y otros de los administradores de control de versiones más actuales funcionan, y es por mucho la forma más utilizada actualmente en administración de control de versiones.

Es imortante recalcar que cada cliente puede trabajar en más de un proyecto al mismo tiempo teniendo muchos repositorios locales en su máquina sin entrar en ningún conflicto.

![](../images/distributed_version_control.png)

\*Imágenes tomadas de [Getting Started About Version Control](https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control)

*** 

### Git

Git es un sistema de administración de control de versiones opensource, creado por Linus Torvalds -creador de Linux- en 2005, basado en BitKeeper -un sistema de administración de control de versiones utilizado en el equipo de desarrollo de Linux de 1991:2002-.

![](../images/pointer.png) En las referencias viene la liga a cómo instalar git en tu sistema operativo.

![](../images/pointer.png) En las referencias viene la liga a cómo configurar git en tu sistema operativo.

#### ¿Cómo funciona Git?

La mayoría de los controladores de versiones piensan en los datos que administran como archivos con cambios realizados -deltas- a través del tiempo, tienen una lista por archivo con los cambios realizados.

![](../images/deltas_files.png)

\* Imagen obtenida de [https://git-scm.com/book/en/v2/Getting-Started-Git-Basics](https://git-scm.com/book/en/v2/Getting-Started-Git-Basics)

Git piensa los datos como un flujo de instantaneas (*snapshots*). 

En Git se guardan instantaneas (o fotografías) del estado completo de un sistema de archivos o *repositorio*. Cada vez que guardamos los cambios, Git guarda como instantanea el estado de como se ven todos los archivos localmene del repositorio en el que te encuentras trabajando y guarda una referencia a esa instantanea; si un archivo no cambió en el momento de tomar el snapshot, Git no guarda el archivo de nuevo, solo deja una referencia al archivo original (la liga al snapshot que guarda ese archivo... seguro alguna vez cambió o alguna vez fue creado). 

![](../images/snapshots_files.png)

\* Imagen obtenida de [https://git-scm.com/book/en/v2/Getting-Started-Git-Basics](https://git-scm.com/book/en/v2/Getting-Started-Git-Basics)

**Características de Git**

+ **Velocidad:** Al tener una copia completa del repositorio remoto en tu máquina local, todos los cambios que realizan todos los clientes se guardan localmente, lo que hace que cualquier cambio realizado y registrado sea muy rápido. En los VCS tradicionales los cambios se hacen a un repositorio remoto, por lo que mandar los cambios requiere una conexión a internet y eso ya implica una latencia.

Si por ejemplo quisieras saber la historia de un archivo, Git tiene el historial localmente y no requiere solicitar nada al repositorio remoto. 

+ **Offline:** Debido a que la copia es local NO necesitas estar conectado a internet para seguir avanzando en lo que estes trabajando. Los cambios se guardan localmente para que después, teniendo una conexión, los subas al repositorio remoto.

+ **Integridad:** Cada cambio realizado en Git tiene asociado un *check sum* generado con un SHA-1 (hash de 40 caracteres hexadecimales) por lo que siempre se utiliza este *check sum* para referenciar cambios/archivos; no puede haber forma de hacer un cambio sin que Git esté enterado del mismo y lo haya registrado. Esta característica permite que no existan archivos corruptos o cambios que se pierdan en el proceso. 

+ **Guardado:** Cada vez que guardas un cambio en Git se genera el hash por cada archivo cambiado en el snapshot y el hash asociado es guardado en una base de datos. Es por este hash que es MUY DIFICIL que haya cosas que no puedas regresar en Git a una versión anterior después de cometer algún error; esta característica brinda más flexibilidad a los miembros de un equipo de desarrollo pues las probabilidades de que algo que hagan sea terrible y no se pueda recuperar/eliminar son muy bajas. 

**Estados**

En Git los archivos pueden estar en 3 estados (principalmente):

1. **Modified:** Los cambios realizados localmente son identificados por Git pero aún NO han sido guardados en la base de datos local de Git por lo que pueden perderse.

2. **Staged:** Archivos que modificaste localmente y que le haz hecho saber a Git que los guarde en la base de datos local y formaran parte del snapshot actual, que es el que subirás al repositorio remoto.

3. **Commited:** Los cambios realizados localmente están almacenados **localmente** en la base de datos de Git.

Estos 3 estados provocan que en un proyecto de Git haya 3 secciones: 

![](../images/git_project_sections.png)

\* Imagen tomada de [https://git-scm.com/book/en/v2/Getting-Started-Git-Basics](https://git-scm.com/book/en/v2/Getting-Started-Git-Basics)

**Workflow**

1. Modificas archivos en tu *working directory*.
2. Pones estos archivos cambiados en stage para enterar a Git de los cambios que formarán parte del siguiente snapshot.
3. Haces *commit* para que Git haga el snapshot del estado actual y registre los cambios en la base de datos y Git sepa qué cosas debe subir en tu siguiente registro de cambios al repositorio remoto.


**Verbos básicos** 

+ `clone`: Copiar localmente un repositorio (y todas sus ramas) `git clone <repo url>`

+ `checkout`: Cambiar de rama en el repositorio local `git checkout <nombre de branch>`

+ `pull`: Bajar los cambios remotos del repositorio en el que estoy trabajando (para tener los cambios de los demás) a mi copia local `git pull <nombre de branch>`

+ `push`: Subir mis cambios locales al repositorio remoto (para que todos los demás puedan después bajar mis cambios) `git pull <nonmbre de branch>`

+ `add`: Agregar un archivo a la base de datos de Git para que le de seguimiento `git add <ruta/archivo(s)>`

+ `commit`: Guardar los cambios (snapshots) que he realizado localmente para después subirlos al repositorio remoto `git commit -m "message"`

+ `branch`: Listar las ramas que existen en el repositorio (locales y/o remotas) `git branch` (ver el cheat sheet para todas las opciones).

+ `merge`: En caso de conflicto entre tus cambios locales y los que existen remotamente se debe hacer un arreglo *manual* juntando los cambios locales con los que existen remotamente `git merge`. Se recomienda instalar [meld](http://meldmerge.org/) como herramienta de merge. 

![](../images/pointer.png) En las referencias está la liga donde se explica cómo configurar Git para que utilice meld como la herramienta de merge.

+ `stash`: Cuando tienes cambios en tu ambiente local que no quieres que se vayan en el siguiente push pero que se queden registrados en tu snapshot para después poder recuperarlos. `git stash` y después `git stash apply` (ver que hay en stash `git stash list`).

+ `log`:  Ver el historial de cambios realizados (localmente) `git log` o de un archivo en particular `git log -p <file>`

+ `status`: Saber qué archivos han sido modificados/eliminados o quáles son los cambios que aún no han sido regristrados (archivos nuevos) `git status`

+ `help`: Solicitar ayuda para conocer los parámetros de algún verbo `git <verbo> --help`

+ `blame`: Saber quién cambio qué y cuándo `git blame <file>`

![](../images/pointer.png) En la referencias viene la liga al *cheat sheet* de Git.


### GitHub - Bitbucket

Git normalmente se utiliza a través de línea de comandos. GitHub es un website donde puedes poner tus repositorios y que consta de una *Graphical User Interface* (GUI) con la cuál interactuar -normalmente se utiliza una combinación entre línea de comando (para administrar tus cambios locales) y la GUI para solicitar revisiones de código (Pull Request).

![](../images/github_logo.png)

BitBucket es otro website con una GUI donde puedes poner tus repositorios de git

![](../images/bitbucket_logo.png)
***

**Características:** 

+ GitHub y Bitbucket permiten aǹadir características al Git que facilitan la administración de repositorios en equipos de desarrollo.

+ Se requiere una cuenta para poder utilizar tanto GitHub como Bitbucket.

+ BitBucket te permite crear repositorios públicos y privados gratuitamente pero solo permite tener 5 miembros a los más colaborando en un repositorio de forma gratuita.

+ GitHub te permite crear repositorios públicos gratuitamente, pero para generar repositorios privados debes pagar ($7 dolares mensuales para usuarios ;), diferente pricing para compaǹías) aquí no hay un máximo de colaboradores para un repositorio público o privado. 

![](../images/pointer.png) En la Maestría en Ciencia de Datos tenemos una licencia "educativa" que nos da acceso gratiuto a un número ilimitado de repositorios provados.

+ GitHub es el más utilizado en la industria. Es la interfaz que se utiliza en la Maestría en Ciencia de Datos.

![](../images/github_prices.png)


**Argot**

+ **Repositorio:** Donde todos los archivos correspondientes a un proyecto son almacenados, se genera una URL única por repositorio. Normalmente se tiene un repositorio por proyecto, pero esto puede complicarse dependiendo de la compaǹía. Por ejemplo, imagina que trabajas en Mozilla, hay un solo producto -FireFox- pero seguro muchos desarrollos con diferentes objetivos. 

+ **Rama:** Una rama dentro dentro de un repositorio se utiliza para aislar parte del trabajo de un proyecto del resto. Un repositorio puede tener varias ramas, sin que una rama afecte a las demás. Se pueden realizar un merge de una rama con otras ramas. Cada repositorio tiene una rama por *default*. 

+ **Fork:** Cuando creas un proyecto nuevo basado en un proyecto existente. Esto se hace cuando deseas agregar funcionalidad a un proyecto existente, pero no formas parte del equipo de desarrollo directamente. 

+ **Pull Request:** Solicitar revisión de los cambios que realizaste. El objetivo es que todos cumplan un estándar de programación y que alguien que no hizo el código verifique desde un punto de vista no sesgado si la solución es correcta, eficiente y cumple con los estándares del lenguaje de programaciónn, del equipo de desarrollo y de la compaǹía; si alguno de los estándares no fue cumplido se dejan comentarios por parte de los revisores del código y solicitan cambios. Si todos los estándares son cumplidos el pull request es aprovado y entonces es posible cerrar el branch asociado y realizar un merge a la rama de develop.
  

### Estrategia recomendada de trabajo en Git

Cuando estas en un equipo de trabajo las cosas se empiezan a complicar ya que todos están trabajando en paralelo, ya sea sobre un mismo problema/proyecto o sobre diferentes partes de él. 

Para administrar correctamente los cambios y que el equipo trabaje eficientemente se recomienda seguir el siguiente modelo de trabajo en Git con varias ramas (*branches*). 

Ramas:

+ `master`: La rama que está en producción.
+ `develop`: La rama a la que vas agregando tus cambios (preproducción). 
+ ramas de issues/tasks. Si estás utilizando git-flow entonces:
     + `feature/issue-number`: Cuando estas agregando alguna funcionalidad que aún no está en producción.
     + `hotfix/issue-number`: Cuando corriges un bug que existe en producción.
     + `release/tag`: cuando vas a liberar cambios completos a producción.

![](../images/branches_strategy.png)


Cuando hagas merge de tu rama a la rama de develop -SOLO debes hacer merge a la rama de develop, y una vez que haz hecho Pull Request y tu Pull Request ha sido APROBADO- hazlo con la bandera *no fast forward* `no-ff` para que quede registro de que existió tu rama y que luego la uniste a develop, sin esta bandera no queda registro de tu rama y pareciera que siempre trabajaste en developv (git Flow hace esto por ti).

![](../images/merge_no_ff.png)

![](../images/pointer.png) Revisa el artículo de "Estrategia sugerida de branching" que viene en las referencias


### Git Flow 

Es una extensión de los comandos de Git que permiten trabajar de manera más sencilla con flujos de trabajo en equipo con Git. 

En particular, facilita la creación de ramas, administrar tus cambios a la rama que creaste, al cerrar un issue/task/bug se hará cargo de subir los cambios a la rama, hacerles merge con la rama develop y borrar la rama remota (con la bandera de *no fast forward* `no-ff`)

El uso de git-flow es completamene opcional pero facilita mucho el uso de Git en el día a día con equipos de trabajo.


### Reglas de etiqueta en Git

<div style="background-color:#ffcf40">
+ Antes de hacer push **PRIMERO** baja todos los cambios del repositorio remoto `git  pull`. De esta manera, si hay conflictos, los puedes resolver antes de cometer errores y empeorar los conflictos en el remoto.

+ Siempre que hagas un commit **COMÉNTALO**, esto es, agrega un comentario que indique qué cambios realizaste `git commit -m "your comment in here"`. 

+ No es necesiario que juntes todos tus cambios (10 por ejemplo) y los subas en un solo commit; si los cambios no están muy relacionados puedes ir haciendo commits por partes para que varios archivos que tienen cambios relacionados queden registrados en un solo comentario de commit. Esto sucede en automático al solicitar un **Pull Request**

+ Todos los días antes de iniciar tus cambios en el repo inicia con un `git pull` 

+ No se te olvide agregar tus cambios a la base de datos local, de otra manera puedes perder tus cambios `git add archivos_modificados.*` seguido de un `git commit -m "your comments in here"`

+ Si cometiste algún error y no sabes cómo solucionarlo, pide ayuda a alguien en tu equipo con mayor experiencia.

+ Sigue el sistema de desarrollo que vimos -ramas para cada issue/task- develop y master, facilita **ENORMEMENTE** el trabajo en equipo.

+ Cuando ya tienes todos los cambios que necesitas para completar un task/issue/bug/etc siempre solicita un Pull Request para que tus cambios sean revisados y aprobados ANTES de que los subas al repositorio remoto $\rightarrow$ cuando solicites el pull request toma como base la rama DEVELOP.

+ Cuando terminas un issue pon en el comentario de cierre de task/issue `closes #<numero de issue>`; eso permitirá que git cierre automáticamente los issues asociados 

</div>



***

### Tutoriales

+ [Git tutorial](https://try.github.io/levels/1/challenges/1)
+ [Git tutorial - atlassian](https://www.atlassian.com/git/tutorials/comparing-workflows)

### Referencias 

+ [Estrategia sugerida de branching](http://nvie.com/posts/a-successful-git-branching-model/)
+ [Getting Started About Version Control](https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control)
+ [Instalar Git en Linux/Mac/Windows](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
+ [Configuración de git](https://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup)
+ [Libro Git](https://git-scm.com/book/en/v2)
+ [SHA-1](https://en.wikipedia.org/wiki/SHA-1)
+ [Git Cheat Sheet](https://www.git-tower.com/blog/git-cheat-sheet/)
+ [Git flow cheat sheet](https://danielkummer.github.io/git-flow-cheatsheet/)
+ [meld - mergetool](http://meldmerge.org/)
+ [Configuración de herramienta de merge](https://git-scm.com/docs/git-mergetool)
+ [Cómo funciona GitHub](https://github.com/features)
+ [GitHub](http://github.com)
+ [Bitbucket](http://bitbucket.org) 
